<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="reset.css" />
    <link rel="stylesheet" href="cht.css" />
    <title>Real Time Chart of Network Traffic</title>
  </head>
  <body>
    <header id="header">
      <p>
        Realtime Traffic Monitor
      </p>
    </header>
    <div id="canvas_wrapper">
      <canvas id="myChart"></canvas>
    </div>

    <div id="description">
      <p>
        山井班テーマ2では 「DHCP
        fingerprintingによる機種依存サービス提供システム」 の制作を行いました。
      </p>
      <p>
        DHCP fingerprintingはOS
        fingerprintingというOSを識別する方法の一つでありDHCPプロトコルを利用します。DHCPはコンピュータがネットワークに接続したときに他のコンピュータと通信するときに必要となるIPアドレスを取得するために利用するプロトコルです。IPアドレスを取得しようとするDHCPクライアントはDHCPサーバを発見するためにDHCP
        DISCOVERパケット、DHCP
        OFFERパケットによってDHCPサーバから提示されたIPアドレスをリクエストするためにDHCP
        REQUESTパケットを送信します。
      </p>
      <img src="image/DHCP.png" alt="DHCP protocol" />
      <p>
        DHCPメッセージのフォーマットは次の画像のようになっており、DHCPクライアントから送信されるDHCP
        DISCOVER、
        REQUESTパケットには赤い点線で囲まれたoptionsの部分にクライアントのOSの情報が含まれるため、これを見ることでOSの識別を行うことができます。
      </p>
      <img src="image/DHCP-format.png" alt="DHCP format" />
      <p>
        実際にiOS、Windows、Androidから送信されたDHCPメッセージをWiresharkでキャプチャしてoptions部分の内容を取り出したものは次のようになっています。DHCPメッセージのoptionsには複数のoption情報が含まれており12番と60番のオプションにOSを識別する情報が入っています。このように今回のシステム制作ではOSを識別するために12番と60番のオプションを見て簡易的にOSの識別を行っていますが、
        これらの値は変更可能なため正確にはOSごとに異なるDHCPメッセージのオプションの番号を見ることでOSの識別を行う必要があります。
        この他にもOSごとの実装の違いによるIP、TCPヘッダのフラグの値の差異によるOSの識別
        （<a href="https://en.wikipedia.org/wiki/P0f">p0f</a>
        というツールで簡単に実行できます）
        を行うことでより精度の高いOSの識別を行うことができます。
      </p>
      <img
        src="image/dhcp-wireshark.PNG"
        alt="option of DHCP message of each OS"
      />
      <p>
        OpenFlowはSDN（Software Defined Network）
        というソフトウェアでネットワークを定義する技術の一つです。
        OpenFlowでは、従来1つのネットワーク機器で行われていたパケットの転送とコントロールを、それぞれOpenFlowスイッチとOpenFlowコントローラに分けて行います。<br />
        OpenFlowスイッチではフローテーブルと呼ばれるテーブルを持ちフローテーブルにはフローエントリが格納されています。
        フローエントリにはパケットのヘッダ情報にマッチする条件と、条件にマッチしたときに実施するアクションが格納されています。
        OpenFlowスイッチでは未知のパケットを受信するとOpenFlowコントローラにPacket-Inメッセージを発行し、OpenFlowコントローラにパケットの処理方法を問い合わせます。
        そして、Packet-Outメッセージによってパケットの送信、Flow-Modメッセージによってフローエントリの更新を行います。
      </p>
      <img src="image/OpenFlow-process.png" alt="process of OpenFlow" />
      <p>
        今回のシステム制作で実際に構築したネットワークの構成は次の図のようになっています。このネットワークでは3つのラズベリーパイを利用し、それぞれDHCPサーバ、DNSサーバ、OpenFlowスイッチ、Webサーバとして利用しました。そしてスイッチングハブでOpenFlowスイッチとアクセスポイントを接続しました。<br />
        このシステムではクライアントから送信されるDHCPメッセージをOpenFlowコントローラで解析し、クライアントのMacアドレスとOSの紐付けを行います。ネットワーク内に設置したWebサーバにWindowsからのアクセスはWindows用のサーバ、それ以外のOSの場合はもう一つのサーバにアクセスを振り分けるようにフローテーブルの追加を行います。
        そのため、DHCPサーバ、Webサーバ、OpenFlowコントローラはクライアントからのアクセスがOpenFlowスイッチを経由するように機器を接続しました。<br />
        OpenFlowスイッチには
        <a href="https://www.openvswitch.org/">Open vSwtich</a>
        、OpenFlowコントローラにはPythonで記述することのできるSDNフレームワークの
        <a href="https://osrg.github.io/ryu/">Ryu</a>
        を使用しました。
      </p>
      <img src="image/network-diagram.png" alt="network diagram" />
      <p>
        このOSごとのネットワークのトラフィックをモニタリングするアプリケーションではOpenFlowスイッチを通過するパケットをポートミラーリングによって一つのポートに集約してOSごとのパケット数をカウントします。そして1秒毎にカウントしたOSごとのパケット数をサーバからすべてのクライアントへ送信します。すべてのクライアントへの送信を終えたらパケットのカウンタを初期化して1秒後に再び送信します。
      </p>
      <p>
        サーバからクライアントにOSごとのトラフィックの情報を送信する方法としてはWebSocketを選択しました。
        これはステートレスな通信を行うHTTPとは異なりステートフルな通信を行うWebSocketを用いることでサーバとクライアントとの通信路を確立し、トラフィックの削減およびサーバからのメッセージの送信を簡潔に行うためです。
        ステートフルな通信のデメリットとしてスケールアウトに弱いという性質がありますが、今回の制作で作成したネットワークの規模が大きくならないことや、多くのクライアントからのアクセスもないと考えられるためスケールアウトは無視しており、サーバはクライアントの情報を保持しステートフルに通信を行いことができると考えました。
        Ajaxによる非同期通信によってサーバからデータを取得することも考えたのですが
        ステートフルな通信によってサーバはコネクションを確立したクライアントの情報を保持し続けるため、クライアントの増加によってサーバの負荷が大きくなるのですが今回の制作で作成したネットワークの規模が小さいことや、多くのクライアントからのアクセスもないと考えられるためステートフルな通信に耐えうると考えました。
      </p>
      <br />
      <div id="refer">
        <ol>
          <li>
            Dynamic Host Configuration Protocol <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://tools.ietf.org/html/rfc2131">
              https://tools.ietf.org/html/rfc2131
            </a>
          </li>
          <li>
            Software-Defined Networking (SDN): Layers and Architecture
            Terminology <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://tools.ietf.org/html/rfc7426">
              https://tools.ietf.org/html/rfc7426
            </a>
          </li>
          <li>
            The Open vSwitch Database Management Protocol <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://tools.ietf.org/html/rfc7047">
              https://tools.ietf.org/html/rfc7047
            </a>
          </li>
          <li>
            Open vSwitch. An Open Virtual Switch <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="http://openvswitch.org/">
              http://openvswitch.org/
            </a>
          </li>
          <li>
            The WebSocket Protocol <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://tools.ietf.org/html/rfc6455">
              https://tools.ietf.org/html/rfc6455
            </a>
          </li>
          <li>
            osrg/ryu <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://github.com/osrg/ryu">
              https://github.com/osrg/ryu
            </a>
          </li>
          <li>
            COMPONENT-BASED SOFTWARE DEFINED NETWORKING FRAMEWORKBuild SDN
            Agilely <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://osrg.github.io/ryu/">
              https://osrg.github.io/ryu/
            </a>
          </li>
          <li>
            Using OpenFlow 1.3 RYU SDN Framework <br />
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://osrg.github.io/ryu-book/ja/Ryubook.pdf">
              https://osrg.github.io/ryu-book/ja/Ryubook.pdf
            </a>
          </li>
          <li>
            かんたん！OpenFlowスタートガイド 五十嵐裕也（Ikarashi
            Hiroya）@山井研
          </li>
        </ol>
      </div>
    </div>

    <script src="./cht.js"></script>
    <!-- <script src="http://localhost/cht.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/locale/af.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.8.0/Chart.bundle.js"></script>
    <script src="./chartjs-plugin-streaming.min.js"></script>
    <!-- <script src="http://localhost/chartjs-plugin-streaming.min.js"></script> -->
  </body>
</html>
